import { accessSync, constants, existsSync, openSync } from 'node:fs';
import { FilesystemError } from '../../../types/errors/FilesystemError';

class VirtualFileDescriptor {
    public filename: string;
    public virtual_fd: number;
    public real_fd: number;
    public seekPosition: number = 0;
    constructor(filename: string, virtual_fd: number, real_fd: number) {
        this.filename = filename;
        this.virtual_fd = virtual_fd;
        this.real_fd = real_fd;
    }
}
export class PassthroughFilesystem {
    private path: string;
    private fd_map = new Map<number, VirtualFileDescriptor>(); // keys are the virtual fds (generated by increamenting fd_counter)
    private fd_counter: number = 1;
    constructor(path: string) {
        // Perform basic tests to check whether the directory is available
        if (path == "/") {
            throw new FilesystemError("Filesystem path should not be the root directory (/)");
        }
        if (path == "") {
            // Use working directory as fallback
            path = ".";
        }
        if (!path.endsWith("/")) {
            path += "/"
        }
        if (!existsSync(path)) {
            throw new FilesystemError(path + " does not exist.")
        }
        accessSync(path, constants.R_OK | constants.W_OK);
        this.path = path;
    }

    public io_seek(fd: number, offset: number): number {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        if (this.fd_map.get(fd)!.seekPosition + offset < 0) {
            // negative seek position
            return -2;
        }
        // node:fs doesnt support direct seek on file descriptors, but instead offset on write commands. Seek is emulated on each write command.
        this.fd_map.get(fd)!.seekPosition += offset;
        return 0;
    }
    public io_close(fd: number) {
        // TODO maybe add return value indicating success/error if invalid fd is given
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return;
        }
        this.fd_map.delete(fd);
    }
    public io_read_buffer(fd: number, buffer: any, b_szie: any): number {
        return 0; // return number of bytes read
    }
    public io_write_buffer(fd: number, buffer: any, b_szie: any): number {
        // fs.writeSync(fd, buffer, offset[, length[, position]])
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        // TODO
        return 0; // return number of bytes written
    }
    public file_create(filename: string) {

    }
    public file_delete(filename: string): number {
        return 0; // return success status
    }
    public file_open(filename: string): number {
        const real_fd = openSync(this.path + filename, "r+");
        const fd = new VirtualFileDescriptor(filename, this.fd_counter++, real_fd);
        this.fd_map.set(fd.virtual_fd, fd);
        return fd.virtual_fd; // returns virtual file descriptor
    }
    public file_stat(filename: string): number {
        return 0; // return file length
    }
}