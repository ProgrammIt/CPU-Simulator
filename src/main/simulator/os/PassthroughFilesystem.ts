import { accessSync, chmodSync, constants, existsSync, lstatSync, openSync, readSync, unlinkSync, writeFileSync, writeSync } from 'node:fs';
import { FilesystemError } from '../../../types/errors/FilesystemError';
import { createInterface } from 'node:readline';
import { DoubleWord } from '../../../types/binary/DoubleWord';

class VirtualFileDescriptor {
    public filename: string;
    public virtual_fd: number;
    public real_fd: number;
    public seek_position: number = 0;
    constructor(filename: string, virtual_fd: number, real_fd: number) {
        this.filename = filename;
        this.virtual_fd = virtual_fd;
        this.real_fd = real_fd;
    }
}

export class PassthroughFilesystem {
    private path: string;
    private fd_map = new Map<number, VirtualFileDescriptor>(); // keys are the virtual file descriptors (generated by increamenting fd_counter)
    private fd_counter: number = 1;
    static readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    private stdin_buffer: Uint8Array[] = [];
    constructor(path: string) {
        // Perform basic tests to check whether the directory is available
        if (path == "/") {
            throw new FilesystemError("Filesystem path should not be the root directory (/)");
        }
        if (path == "") {
            // Use working directory as fallback
            path = ".";
        }
        if (!path.endsWith("/")) {
            path += "/"
        }
        if (!existsSync(path)) {
            throw new FilesystemError(path + " does not exist.")
        }
        accessSync(path, constants.R_OK | constants.W_OK);
        this.path = path;
        PassthroughFilesystem.readline.on('line', (input) => {
            this.stdin_buffer.push(Buffer.from(input, 'latin1')); // interpret string as 8 bit characters
        });
    }

    public io_seek(fd: number, offset: number, mode: number): number {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        const vfd = this.fd_map.get(fd)!

        let new_seek_postion = 0;
        switch (mode) {
            case 0: // 0 - Seek from current position
                new_seek_postion = vfd.seek_position + offset;
                break;
            case 1: // 1 - Seek from start of file
                new_seek_postion = offset;
                break;
            case 2: // 2 - Seek from end of file
                this.file_stat(vfd.filename)
                // TODO error handling if file_stat fails due to race condition
                new_seek_postion = this.file_stat(vfd.filename) - offset;
                break;
            default:
                // unkown mode
                return -4;
                break;
        }

        if (this.file_stat(vfd.filename) < vfd.seek_position) {
            // seek position out of bounds
            return -2;
        }
        if (vfd.seek_position + offset < 0) {
            // negative seek position
            return -3;
        }
        // node:fs doesnt support seek() on file descriptors, but allows it on write commands. Seek is emulated on each write command.
        vfd.seek_position += offset;
        return 0;
    }

    public io_close(fd: number) {
        // TODO maybe add return value indicating success/error if invalid fd is given
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return;
        }
        this.fd_map.delete(fd);
    }

    public io_read_buffer(fd: number, buffer: Uint8Array, size: number): number {
        if (fd != 0) {
            if (!this.fd_map.has(fd)) {
                // invalid fd
                return -1;
            }
            const vfd = this.fd_map.get(fd)!
            if (this.file_stat(vfd.filename) < vfd.seek_position) {
                // invalid seek position
                return -2;
            }
            return readSync(vfd.real_fd, buffer, 0, size, vfd.seek_position)
        } else {
            // fd=0 -> console input
            if (this.stdin_buffer.length === 0) {
                // no console input ready
                return -3;
            }
            const current: Uint8Array = this.stdin_buffer[0];
            const input_len = current.length;
            let bytes_read = 0;
            while (input_len > bytes_read && size > bytes_read) {
                buffer[bytes_read] = current[bytes_read];
                bytes_read++
            }
            if (bytes_read === input_len) {
                // read all characters from the line, remove it from the stdin_buffer list
                this.stdin_buffer.shift();
            } else {
                // not all characters from the stdin buffer have been read because the buffer from the OS was too small
                // remove the characters that have been read
                this.stdin_buffer[0] = current.slice(bytes_read);
            }
            return bytes_read;
        }
        
    }

    public io_write_buffer(fd: number, buffer: Uint8Array, size: number): number {
        if (fd != 0) {
           if (!this.fd_map.has(fd)) {
                // invalid fd
                return -1;
            }
            const vfd = this.fd_map.get(fd)!
            if (this.file_stat(vfd.filename) < vfd.seek_position) {
                // invalid seek position
                return -2;
            }
            const bytes_written: number = writeSync(vfd.real_fd, buffer, 0, size, vfd.seek_position);
            vfd.seek_position += bytes_written;
            return bytes_written;
        } else {
            // fd=0 -> console output
            console.log(new TextDecoder('latin1').decode(buffer));
            return buffer.length;
        }
    }

    public file_create(filename: string) {
        const path = this.path + filename
        if (existsSync(path)) {
            // file does already exist
            return -1;
        }
        writeFileSync(path, "", {mode: 0o777, flag: "w+"})
        chmodSync(path, 0o777)
        return 0;
    }

    public file_delete(filename: string): number {
        const path = this.path + filename
        if (!existsSync(path)) {
            // file does not exist
            return -1;
        }
        unlinkSync(path)
        return 0;
    }

    public file_open(filename: string): number {
        if (this.file_stat(filename) < 0) {
            return -1;
        }
        const path = this.path + filename
        const real_fd = openSync(path, "r+", constants.O_RDWR);
        const vfd = new VirtualFileDescriptor(filename, this.fd_counter++, real_fd);
        this.fd_map.set(vfd.virtual_fd, vfd);
        return vfd.virtual_fd;
    }

    public file_stat(filename: string): number {
        const path = this.path + filename
        if (!existsSync(path)) {
            // file does not exist
            return -1;
        }
        const stat = lstatSync(path)
        if (!stat.isFile || stat.isDirectory()) {
            // not a file
            return -2;
        }
        return stat.size;
    }

    public console_print_number(num: number) {
        console.log(num);
    }

    public console_read_number(): [number, number] {
        if (this.stdin_buffer.length === 0) {
            // error -1 -> no input ready
            return [0, -1];
        }
        const line = this.stdin_buffer[0]
        this.stdin_buffer.shift();
        const num = parseInt(new TextDecoder('latin1').decode(line));
        if (isNaN(num)) {
            // error -2 -> could not parse number
            return [0, -2];
        }
        if (num > DoubleWord.MAXIMUM_NUMBER_DEC || num < DoubleWord.MINIMUM_NUMBER_DEC) {
            // error -2 -> number does not fit into signed 32 bit DoubleWord
            return [0, -3]
        }
        return [num, 0];
    }
}