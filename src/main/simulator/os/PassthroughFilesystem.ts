import { accessSync, constants, existsSync, lstatSync, openSync, readSync, writeSync } from 'node:fs';
import { FilesystemError } from '../../../types/errors/FilesystemError';

class VirtualFileDescriptor {
    public filename: string;
    public virtual_fd: number;
    public real_fd: number;
    public seek_position: number = 0;
    constructor(filename: string, virtual_fd: number, real_fd: number) {
        this.filename = filename;
        this.virtual_fd = virtual_fd;
        this.real_fd = real_fd;
    }
}
export class PassthroughFilesystem {
    private path: string;
    private fd_map = new Map<number, VirtualFileDescriptor>(); // keys are the virtual fds (generated by increamenting fd_counter)
    private fd_counter: number = 1;
    constructor(path: string) {
        // Perform basic tests to check whether the directory is available
        if (path == "/") {
            throw new FilesystemError("Filesystem path should not be the root directory (/)");
        }
        if (path == "") {
            // Use working directory as fallback
            path = ".";
        }
        if (!path.endsWith("/")) {
            path += "/"
        }
        if (!existsSync(path)) {
            throw new FilesystemError(path + " does not exist.")
        }
        accessSync(path, constants.R_OK | constants.W_OK);
        this.path = path;
    }

    public io_seek(fd: number, offset: number): number {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        const vfd = this.fd_map.get(fd)!
        if (this.file_stat(vfd.filename) < vfd.seek_position) {
            // seek position out of bounds
            return -2;
        }
        if (vfd.seek_position + offset < 0) {
            // negative seek position
            return -3;
        }
        // node:fs doesnt support seek() on file descriptors, but allows it on write commands. Seek is emulated on each write command.
        vfd.seek_position += offset;
        return 0;
    }

    public io_close(fd: number) {
        // TODO maybe add return value indicating success/error if invalid fd is given
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return;
        }
        this.fd_map.delete(fd);
    }

    public io_read_buffer(fd: number, size: number): [number, Uint8Array?] {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return [-1, undefined];
        }
        const vfd = this.fd_map.get(fd)!
        if (this.file_stat(vfd.filename) < vfd.seek_position) {
            // invalid seek position
            return [-2, undefined];
        }
        const buffer = new Uint8Array(size)
        const bytes_read: number = readSync(vfd.real_fd, buffer, 0, size, vfd.seek_position)
        return [bytes_read, buffer]
    }

    public io_write_buffer(fd: number, buffer: Uint8Array): number {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        const vfd = this.fd_map.get(fd)!
        if (this.file_stat(vfd.filename) < vfd.seek_position) {
            // invalid seek position
            return -2;
        }
        const bytes_written: number = writeSync(vfd.real_fd, buffer, 0, buffer.byteLength, vfd.seek_position);
        vfd.seek_position += bytes_written;
        return bytes_written;
    }

    public file_create(filename: string) {

    }
    
    public file_delete(filename: string): number {
        return 0; // return success status
    }

    public file_open(filename: string): number {
        const real_fd = openSync(this.path + filename, "r+");
        const vfd = new VirtualFileDescriptor(filename, this.fd_counter++, real_fd);
        this.fd_map.set(vfd.virtual_fd, vfd);
        return vfd.virtual_fd; // returns virtual file descriptor
    }

    public file_stat(filename: string): number {
        const path = this.path + filename
        if (!existsSync(path)) {
            // file does not exist
            return -1;
        }
        const stat = lstatSync(path)
        if (!stat.isFile) {
            // not a file
            return -2;
        }
        return stat.size;
    }
}