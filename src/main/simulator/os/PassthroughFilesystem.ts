import { accessSync, chmodSync, constants, existsSync, lstatSync, openSync, readSync, unlinkSync, writeFileSync, writeSync } from 'node:fs';
import { FilesystemError } from '../../../types/errors/FilesystemError';

class VirtualFileDescriptor {
    public filename: string;
    public virtual_fd: number;
    public real_fd: number;
    public seek_position: number = 0;
    constructor(filename: string, virtual_fd: number, real_fd: number) {
        this.filename = filename;
        this.virtual_fd = virtual_fd;
        this.real_fd = real_fd;
    }
}
export class PassthroughFilesystem {
    private path: string;
    private fd_map = new Map<number, VirtualFileDescriptor>(); // keys are the virtual fds (generated by increamenting fd_counter)
    private fd_counter: number = 1;
    constructor(path: string) {
        // Perform basic tests to check whether the directory is available
        if (path == "/") {
            throw new FilesystemError("Filesystem path should not be the root directory (/)");
        }
        if (path == "") {
            // Use working directory as fallback
            path = ".";
        }
        if (!path.endsWith("/")) {
            path += "/"
        }
        if (!existsSync(path)) {
            throw new FilesystemError(path + " does not exist.")
        }
        accessSync(path, constants.R_OK | constants.W_OK);
        this.path = path;
    }

    public io_seek(fd: number, offset: number, mode: number): number {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        const vfd = this.fd_map.get(fd)!

        let new_seek_postion = 0;
        switch (mode) {
            case 0: // 0 - Seek from current position
                new_seek_postion = vfd.seek_position + offset;
                break;
            case 1: // 1 - Seek from start of file
                new_seek_postion = offset;
                break;
            case 2: // 2 - Seek from end of file
                this.file_stat(vfd.filename)
                // TODO error handling if file_stat fails due to race condition
                new_seek_postion = this.file_stat(vfd.filename) - offset;
                break;
            default:
                // unkown mode
                return -4;
                break;
        }

        if (this.file_stat(vfd.filename) < vfd.seek_position) {
            // seek position out of bounds
            return -2;
        }
        if (vfd.seek_position + offset < 0) {
            // negative seek position
            return -3;
        }
        // node:fs doesnt support seek() on file descriptors, but allows it on write commands. Seek is emulated on each write command.
        vfd.seek_position += offset;
        return 0;
    }

    public io_close(fd: number) {
        // TODO maybe add return value indicating success/error if invalid fd is given
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return;
        }
        this.fd_map.delete(fd);
    }

    public io_read_buffer(fd: number, buffer: Uint8Array, size: number): number {
        if (!this.fd_map.has(fd)) {
            // invalid fd
            return -1;
        }
        const vfd = this.fd_map.get(fd)!
        if (this.file_stat(vfd.filename) < vfd.seek_position) {
            // invalid seek position
            return -2;
        }
        const bytes_read: number = readSync(vfd.real_fd, buffer, 0, size, vfd.seek_position)
        return bytes_read
    }

    public io_write_buffer(fd: number, buffer: Uint8Array, size: number): number {
        if (fd != 0) {
           // fd=0 -> console output
           if (!this.fd_map.has(fd)) {
                // invalid fd
                return -1;
            }
            const vfd = this.fd_map.get(fd)!
            if (this.file_stat(vfd.filename) < vfd.seek_position) {
                // invalid seek position
                return -2;
            }
            const bytes_written: number = writeSync(vfd.real_fd, buffer, 0, size, vfd.seek_position);
            vfd.seek_position += bytes_written;
            return bytes_written;
        } else {
            console.log(buffer);
            return buffer.length;
        }
        
        
    }

    public file_create(filename: string) {
        const path = this.path + filename
        if (existsSync(path)) {
            // file does already exist
            return -1;
        }
        writeFileSync(path, "", {mode: 0o777, flag: "w+"})
        chmodSync(path, 0o777)
        return 0;
    }

    public file_delete(filename: string): number {
        const path = this.path + filename
        if (!existsSync(path)) {
            // file does not exist
            return -1;
        }
        unlinkSync(path)
        return 0;
    }

    public file_open(filename: string): number {
        if (this.file_stat(filename) < 0) {
            return -1;
        }
        const path = this.path + filename
        const real_fd = openSync(path, "r+", constants.O_RDWR);
        const vfd = new VirtualFileDescriptor(filename, this.fd_counter++, real_fd);
        this.fd_map.set(vfd.virtual_fd, vfd);
        return vfd.virtual_fd;
    }

    public file_stat(filename: string): number {
        const path = this.path + filename
        if (!existsSync(path)) {
            // file does not exist
            return -1;
        }
        const stat = lstatSync(path)
        if (!stat.isFile || stat.isDirectory()) {
            // not a file
            return -2;
        }
        return stat.size;
    }
}