import { app, BrowserWindow, dialog, ipcMain, IpcMainInvokeEvent, Menu, nativeImage, shell } from 'electron';
import * as path from 'path';
import { NumberSystems } from '../types/enumerations/NumberSystems';
import { Byte } from './../types/binary/Byte';
import { DoubleWord } from './../types/binary/DoubleWord';
import { PhysicalAddress } from './../types/binary/PhysicalAddress';
import { twosComplementToDecimal } from './../helper';
import { SimulationController } from './simulator/SimulationController';
import appIcon from './../../assets/icons/app/icon.png';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
	app.quit();
}

app.setAppUserModelId("de.hs-hannover.IhmeCoreX1Simulator.IhmeCoreX1Simulator");

const buildMenu = (win: BrowserWindow, simulator: SimulationController): Menu => {
	const menu = Menu.buildFromTemplate([
		{
			label: "App",
			submenu: [
				{
					label: "Exit",
					accelerator: "CmdOrCtrl+Q",
					click() {
						app.quit()
					} 
				}
			]
		},
		{
			label: "File",
			submenu: [
				{
					label: "Open Assembly Program",
					accelerator: "CmdOrCtrl+O",
					click() {
						dialog.showOpenDialog({
							properties: ["openFile", "createDirectory"],
							filters: [{ name: "Assembly Files", extensions: ['asm'] }]
						}).then(function(fileObj) {
							if (!fileObj.canceled) {
								simulator.bootProcess(fileObj.filePaths[0]);
								win.webContents.send("loaded_program", fileObj.filePaths);
							}
						}).catch((err) => win.webContents.send("on_error", err))
					}
				}
			],
		},
		{
			label: "Settings",
			submenu: [
				{
					label: "Behavior",
					submenu: [
						{
							label: "Physical RAM",
							submenu : [
								{
									label: "Disable Auto Scroll",
									click() {
										if (simulator.autoScrollForPhysicalRAMEnabled) {
											win.webContents.send("disable_auto_scroll_physical_ram");
										}
									}
								},
								{
									label: "Enable Auto Scroll",
									click() {
										if (!simulator.autoScrollForPhysicalRAMEnabled) {
											win.webContents.send("enable_auto_scroll_physical_ram");
										}
									}
								}
							]
						},
						{
							label: "Virtual RAM",
							submenu : [
								{
									label: "Disable Auto Scroll",
									click() {
										if (simulator.autoScrollForVirtualRAMEnabled) {
											win.webContents.send("disable_auto_scroll_virtual_ram");
										}
									}
								},
								{
									label: "Enable Auto Scroll",
									click() {
										if (!simulator.autoScrollForVirtualRAMEnabled) {
											win.webContents.send("enable_auto_scroll_virtual_ram");
										}
									}
								}
							]
						},
						{
							label: "Page Table",
							submenu : [
								{
									label: "Disable Auto Scroll",
									click() {
										if (simulator.autoScrollForPageTableEnabled) {
											win.webContents.send("disable_auto_scroll_page_table");
										}
									}
								},
								{
									label: "Enable Auto Scroll",
									click() {
										if (!simulator.autoScrollForPageTableEnabled) {
											win.webContents.send("enable_auto_scroll_page_table");
										}
									}
								}
							]
						}
					]
				}
			]
		},
		{
			label: "Window",
			submenu: [
				{
					label: "Minimize",
					accelerator: "CmdOrCtrl+M",
					click() {
						if (win.isMinimizable() && !win.isMinimized()) {
							win.minimize();
						}
					}
				},
				{
					label: "Reload",
					accelerator: "CmdOrCtrl+R",
					click() {
						win.webContents.reload()
					}
				},
				{
					label: "Force Reload",
					accelerator: "CmdOrCtrl+Shift+R",
					click() {
						win.webContents.reloadIgnoringCache()
					}
				},
				{
					label: "Toggle Developer Tools",
					accelerator: "CmdOrCtrl+Shift+I",
					click() {
						win.webContents.openDevTools();
					}
				}
			]
		},
		{
			label: "Help",
			submenu: [
				{
					label: "Documentation",
					accelerator: "CmdOrCtrl+H",
					click() {
						shell.openExternal("https://programmit.github.io/CPU-Simulator/")
					}
				},
				{
					label: "GitHub Repository",
					click() {
						shell.openExternal("https://github.com/ProgrammIt/CPU-Simulator")
					}
				}
			]
		}
	]);
	return menu;
};

const createWindow = (): void => {
	// Create the browser window.
	const mainWindow = new BrowserWindow({
		height: 600,
		width: 800,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
		icon: path.resolve(__dirname, appIcon),
	});

	// Open the DevTools.
	// mainWindow.webContents.openDevTools();

	let pathToLanguageDefinition: string;
	let pathToAssembly: string;
	if (app.isPackaged) {
		pathToLanguageDefinition = `${process.resourcesPath}/settings/language_definition.json`;
		pathToAssembly = `${process.resourcesPath}/assembly/`;
	} else {
		pathToLanguageDefinition = "./settings/language_definition.json";
		pathToAssembly = "./assembly/";
	}
	
	const simulator = SimulationController.getInstance(
		Math.pow(2, 32),
		pathToLanguageDefinition,
		pathToAssembly
	);
	
	registerHandlers(simulator, mainWindow);

	// Set the menu bar.
	const menu = buildMenu(mainWindow, simulator);
	Menu.setApplicationMenu(menu);

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

const registerHandlers = (simulator: SimulationController, win: BrowserWindow): void => {
	ipcMain.on('get-preload-path', (e) => {
		e.returnValue = MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY;
	});
	
	ipcMain.handle("readRangeFromPhysicalMemory", async (event: Electron.IpcMainInvokeEvent, fromPhysicalAddressHexString: string, toPhysicalAddressHexString: string): Promise<Map<string, string>> => {
		const tmp: Map<string, string> = new Map<string, string>();
		const fromPhysicalAddressDec: number = parseInt(fromPhysicalAddressHexString, 16);
		const toPhysicalAddressDec: number = parseInt(toPhysicalAddressHexString, 16);
		for (let i = fromPhysicalAddressDec; i <= toPhysicalAddressDec; ++i) {
			const byte: Byte = simulator.mainMemory.readByteFrom(PhysicalAddress.fromInteger(i));
			tmp.set(`0x${(i).toString(16)}`, byte.toString());
		}
		return tmp;
	});

	ipcMain.handle("readFromPhysicalMemory", async (event: Electron.IpcMainInvokeEvent, physicalAddressHexString: string): Promise<string> => {
		const physicalAddressDec: number = parseInt(physicalAddressHexString, 16);
		const byte: Byte = simulator.mainMemory.readByteFrom(PhysicalAddress.fromInteger(physicalAddressDec));
		return byte.toString();
	});

	ipcMain.handle("readRangeFromVirtualMemory", async (event: Electron.IpcMainInvokeEvent, fromVirtualAddressHexString: string, toVirtualAddressHexString: string): Promise<Map<string, string>> => {
		const tmp: Map<string, string> = new Map<string, string>();
		const fromPhysicalAddressDec: number = parseInt(fromVirtualAddressHexString, 16);
		const toPhysicalAddressDec: number = parseInt(toVirtualAddressHexString, 16);
		for (let i = fromPhysicalAddressDec; i <= toPhysicalAddressDec; ++i) {
			const byte: Byte = simulator.core.mmu.readByteFrom(PhysicalAddress.fromInteger(i));
			tmp.set(`0x${(i).toString(16)}`, byte.toString());
		}
		return tmp;
	});

	ipcMain.handle("readFromVirtualMemory", async (event: Electron.IpcMainInvokeEvent, virtualAddressHexString: string): Promise<string> => {
		const virtualAddressDec: number = parseInt(virtualAddressHexString, 16);
		const byte: Byte = simulator.core.mmu.readByteFrom(PhysicalAddress.fromInteger(virtualAddressDec));
		return byte.toString();
	});

	ipcMain.handle("retrieveMainMemoryCells", async (): Promise<Map<string, string>> => {
		const tmp: Map<string, string> = new Map<string, string>();
		simulator.mainMemory.cells.forEach((byte, address) => {
			tmp.set(address, byte.toString());
		});
		return tmp;
	});

	ipcMain.handle("readPageTableEntries", async (event: Electron.IpcMainInvokeEvent, firstPageNumberToReadDec: number, lastPageNumberToReadDec: number): Promise<Map<string, string>> => {
		const tmp: Map<string, string> = new Map<string, string>();
		const fromPhysicalAddressDec: number = firstPageNumberToReadDec + parseInt(simulator.core.ptp.content.toString(), 2);
		const toPhysicalAddressDec: number = lastPageNumberToReadDec + parseInt(simulator.core.ptp.content.toString(), 2);
		let currentPageFrameNumber: number = firstPageNumberToReadDec;
		let currentPhysicalAddressDec: number = fromPhysicalAddressDec;
		while (currentPhysicalAddressDec <= toPhysicalAddressDec) {
			const pageTableEntry: DoubleWord = simulator.mainMemory.readDoublewordFrom(PhysicalAddress.fromInteger(currentPhysicalAddressDec));
			const currentPageFrameNumberBinaryString: string = currentPageFrameNumber.toString(2)
				.padStart(20, "0")
				.padEnd(32, "0");
			tmp.set(currentPageFrameNumberBinaryString, pageTableEntry.toString());
			currentPhysicalAddressDec += 4;
			currentPageFrameNumber += 1;
		}
		return tmp;
	});

	ipcMain.handle("readEAX", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content: DoubleWord = simulator.core.eax.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${twosComplementToDecimal(content).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${twosComplementToDecimal(content)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readEBX", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content: DoubleWord = simulator.core.ebx.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${twosComplementToDecimal(content).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${twosComplementToDecimal(content)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readECX", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content: DoubleWord = simulator.core.edx.content;
		let result: string = twosComplementToDecimal(content).toString(basis);
		if (basis === NumberSystems.HEX) {
			result = `0x${twosComplementToDecimal(content).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${twosComplementToDecimal(content)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readEIP", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.eip.content;
		let result: string = parseInt(content.toString(), 2).toString(basis);
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readEFLAGS", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.eflags.content;
		return content.toString();
	});

	ipcMain.handle("readEIR", async (event: IpcMainInvokeEvent, asInstruction: boolean): Promise<string> => {
		if (asInstruction) {
			// TODO
		}
		const content = simulator.core.eir.content;
		return content.toString(true);
	});

	ipcMain.handle("readNPTP", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.nptp.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readVMPTR", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.vmtpr.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readESP", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.esp.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readITP", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.itp.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readGPTP", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		if (simulator.core.gptp === null) {
			return "-";
		}
		const content = simulator.core.gptp.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("readPTP", async (event: IpcMainInvokeEvent, basis: NumberSystems): Promise<string> => {
		const content = simulator.core.ptp.content;
		let result: string;
		if (basis === NumberSystems.HEX) {
			result = `0x${parseInt(content.toString(), 2).toString(16)}`;
		} else if (basis === NumberSystems.DEC) {
			result = `${parseInt(content.toString(), 2)}`;
		} else {
			result = content.toString(true);
		}
		return result;
	});

	ipcMain.handle("nextCycle", async (): Promise<boolean> => {
		let resultOfCycle = false;
		try {
			resultOfCycle = simulator.cycle();
		} catch (error) {
			if (error instanceof Error) {
				win.webContents.send("error", error.message);
			}
		}
		return resultOfCycle;
	});

	ipcMain.handle("on_disable_auto_scroll_physical_ram", async (): Promise<void> => {
		simulator.autoScrollForPhysicalRAMEnabled = false;
		return;
	});

	ipcMain.handle("on_ensable_auto_scroll_physical_ram", async (): Promise<void> => {
		simulator.autoScrollForPhysicalRAMEnabled = true;
		return;
	});

	ipcMain.handle("on_disable_auto_scroll_virtual_ram", async (): Promise<void> => {
		simulator.autoScrollForVirtualRAMEnabled = false;
		return;
	});

	ipcMain.handle("on_ensable_auto_scroll_virtual_ram", async (): Promise<void> => {
		simulator.autoScrollForVirtualRAMEnabled = true;
		return;
	});

	ipcMain.handle("on_disable_auto_scroll_page_table", async (): Promise<void> => {
		simulator.autoScrollForPageTableEnabled = false;
		return;
	});

	ipcMain.handle("on_enable_auto_scroll_page_table", async (): Promise<void> => {
		simulator.autoScrollForPageTableEnabled = true;
		return;
	});
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
	if (process.platform !== 'darwin') {
		app.quit();
	}
});

app.on('activate', () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow();
	}
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
